<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <title>test4 | Nangman's Research Lab</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    .hero {
      position: relative;
      background: url('/assets/images/header-bg.jpg') center/cover no-repeat;
      padding: 4rem 2rem 6rem;
      color: white;
      text-align: center;
    }

    .hero h2 {
      font-size: 2rem;
      margin-bottom: 2rem;
    }

    .carousel-container {
      position: relative;
      max-width: 1100px;
      margin: 0 auto;
      perspective: 1200px;
      /* 3D 효과를 위한 원근감 추가 */
      display: flex;
      justify-content: center;
    }

    .carousel {
      position: relative;
      width: 100%;
      max-width: 1200px;
      height: 32vw;
      max-height: 340px;
      min-height: 200px;
      overflow: visible;
      /* 원형 회전을 위해 overflow를 visible로 변경 */
      margin: 0 auto;
      box-sizing: border-box;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .carousel-track {
      position: relative;
      width: 100%;
      height: 100%;
      transform-style: preserve-3d;
      /* 3D 변환 유지 */
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .carousel-card {
      position: absolute;
      width: calc(20% - 2vw);
      /* 원래 크기로 복원 (16% → 20%) */
      height: 90%;
      margin: 0 1vw;
      background: rgba(30, 30, 30, 0.85);
      border-radius: 12px;
      overflow: hidden;
      color: white;
      text-decoration: none;
      transition:
        transform 0.4s cubic-bezier(.4, 2.2, .2, 1),
        opacity 0.4s,
        filter 0.4s;
      opacity: 0.5;
      filter: blur(2px);
      transform-origin: center center;
      box-sizing: border-box;
      backface-visibility: hidden;
      /* 성능 최적화 */
    }

    .carousel-card.active {
      opacity: 1;
      transform: scale(1.1) translateZ(150px);
      /* Z축으로 돌출 효과 */
      filter: blur(0);
      z-index: 10;
    }

    .carousel-card img {
      width: 100%;
      height: 55%;
      object-fit: cover;
    }

    .carousel-card .text {
      padding: 1rem;
    }

    .carousel-card h3 {
      margin: 0 0 0.5rem;
      font-size: 1.1rem;
    }

    .carousel-card small {
      color: #ccc;
    }

    .nav-btn {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(20, 20, 20, 0.5);
      color: white;
      border: none;
      font-size: 2rem;
      cursor: pointer;
      padding: 0 0.8rem;
      z-index: 20;
      border-radius: 50%;
      /* 둥근 버튼 */
      width: 50px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .nav-btn.left {
      left: 0;
    }

    .nav-btn.right {
      right: 0;
    }

    @media (max-width: 900px) {
      .carousel-card {
        width: calc(33.333% - 2vw);
        /* 원래 반응형 크기로 복원 */
      }
    }

    @media (max-width: 600px) {
      .carousel-card {
        width: calc(80% - 2vw);
        margin: 0 2vw;
      }

      .carousel {
        height: 60vw;
        min-height: 180px;
      }
    }
  </style>

  <!-- 스크립트를 head에 넣어 빠르게 로드 -->
  <script>
    // 즉시 실행 함수로 변수 스코프 제한
    (function () {
      // 페이지 로드 전에 필요한 변수 미리 선언
      let track, carousel, cards = [], cardCount = 0;
      let carouselWidth, carouselHeight;
      let currentIndex = 0; // 현재 활성화된 카드 인덱스
      let animationId = null; // 애니메이션 ID
      let isAnimating = false; // 애니메이션 진행 상태
      
      // 타원 회전을 위한 파라미터
      let radiusX; // 타원 장축 반경
      let radiusY; // 타원 단축 반경

      // DOM이 로드되자마자 즉시 실행
      function init() {
        carousel = document.querySelector('.carousel');
        if (!carousel) return; // 캐러셀이 없는 페이지에서 오류 방지

        track = document.querySelector('.carousel-track');
        if (!track) return;

        // 원본 카드 저장
        const originalCards = Array.from(document.querySelectorAll('.carousel-card'));
        cardCount = originalCards.length;
        if (cardCount === 0) return;

        // 캐러셀 크기 계산
        carouselWidth = carousel.offsetWidth;
        carouselHeight = carousel.offsetHeight;

        // 타원 반경 계산 - 캐러셀 중앙을 기준으로 함
        radiusX = carouselWidth * 0.4;
        radiusY = carouselHeight * 0.1;

        // 트랙 내용 비우기
        track.innerHTML = '';

        // 중앙 기준점 설정을 위한 스타일 추가
        track.style.position = 'relative';

        // 카드 생성 및 배치
        originalCards.forEach((card, i) => {
          const clone = card.cloneNode(true);
          clone.style.position = 'absolute';
          track.appendChild(clone);
          cards.push(clone);
        });

        // 초기 위치에 카드 배치
        updateCardPositions();

        // 각 카드에 클릭 이벤트 추가
        cards.forEach((card, i) => {
          card.addEventListener('click', function (e) {
            // 만약 활성 카드가 아니면 해당 카드로 이동
            if (!card.classList.contains('active') && !isAnimating) {
              e.preventDefault();
              goToCard(i);
            }
          });
        });

        // 캐러셀 버튼 이벤트 연결
        const rightBtn = document.querySelector('.nav-btn.right');
        const leftBtn = document.querySelector('.nav-btn.left');

        if (rightBtn) rightBtn.addEventListener('click', goNext);
        if (leftBtn) leftBtn.addEventListener('click', goPrev);

        // 드래그 기능 구현
        let isDragging = false;
        let startX = 0;
        let startIndex = 0;
        let dragDistance = 0;

        carousel.addEventListener('mousedown', function (e) {
          if (isAnimating) return;
          isDragging = true;
          startX = e.clientX;
          startIndex = currentIndex;
          document.body.style.cursor = 'grabbing';
        });

        carousel.addEventListener('touchstart', function (e) {
          if (isAnimating) return;
          isDragging = true;
          startX = e.touches[0].clientX;
          startIndex = currentIndex;
        });

        document.addEventListener('mousemove', function (e) {
          if (!isDragging) return;
          dragDistance = e.clientX - startX;
          const dragProgress = Math.min(Math.max(dragDistance / carouselWidth * 2, -1), 1);
          
          // 드래그 시 중간 상태 표시
          updateCardPositions(dragProgress);
        });

        document.addEventListener('touchmove', function (e) {
          if (!isDragging) return;
          dragDistance = e.touches[0].clientX - startX;
          const dragProgress = Math.min(Math.max(dragDistance / carouselWidth * 2, -1), 1);
          
          // 드래그 시 중간 상태 표시
          updateCardPositions(dragProgress);
        });

        document.addEventListener('mouseup', function () {
          if (!isDragging) return;
          isDragging = false;
          document.body.style.cursor = '';

          // 드래그 거리에 따라 다음/이전 카드로 이동 또는 원래 위치로 복귀
          if (dragDistance < -50) {
            goNext();
          } else if (dragDistance > 50) {
            goPrev();
          } else {
            goToCard(currentIndex);
          }
        });

        document.addEventListener('touchend', function () {
          if (!isDragging) return;
          isDragging = false;

          // 드래그 거리에 따라 다음/이전 카드로 이동 또는 원래 위치로 복귀
          if (dragDistance < -50) {
            goNext();
          } else if (dragDistance > 50) {
            goPrev();
          } else {
            goToCard(currentIndex);
          }
        });

        // 창 크기 변경 시 다시 계산
        window.addEventListener('resize', function () {
          carouselWidth = carousel.offsetWidth;
          carouselHeight = carousel.offsetHeight;
          radiusX = carouselWidth * 0.4;
          radiusY = carouselHeight * 0.1;
          updateCardPositions();
        });

        // 첫 번째 카드를 활성화
        goToCard(0);
      }

      // 카드 위치 계산 및 업데이트
      function updateCardPositions(offset = 0) {
        if (!cards.length) return;

        const angleStep = (2 * Math.PI) / cardCount;
        
        cards.forEach((card, i) => {
          // 카드 인덱스와 현재 인덱스의 차이를 계산 (원형 거리 고려)
          let distance = i - (currentIndex + offset);
          
          // 최단 경로 계산 (원형)
          if (distance > cardCount / 2) distance -= cardCount;
          if (distance < -cardCount / 2) distance += cardCount;
          
          // 각도 계산
          const angle = distance * angleStep;
          
          // 좌표 계산
          const x = radiusX * Math.sin(angle);
          const z = radiusX * Math.cos(angle);
          
          // 스케일 및 투명도 계산
          const scale = map(z, -radiusX, radiusX, 0.7, 1.0);
          const opacity = map(z, -radiusX, radiusX, 0.5, 1.0);
          const blur = z < 0 ? 2 : 0;
          const zIndex = Math.round(map(z, -radiusX, radiusX, 1, 100));
          
          // 스타일 적용
          card.style.transform = `translate3d(${x}px, 0, ${z}px) scale(${scale})`;
          card.style.opacity = opacity;
          card.style.filter = `blur(${blur}px)`;
          card.style.zIndex = zIndex;
          
          // 정면에 있는 카드 활성화 (거리가 0에 가장 가까운 카드)
          card.classList.toggle('active', Math.abs(distance) < 0.1);
        });
      }

      // 특정 카드로 이동
      function goToCard(index) {
        if (isAnimating) return;
        isAnimating = true;
        
        // 유효한 인덱스로 정규화
        const targetIndex = ((index % cardCount) + cardCount) % cardCount;
        
        // 이동 애니메이션
        const startIndex = currentIndex;
        const startTime = performance.now();
        const duration = 400; // 애니메이션 시간 (ms)
        
        function animate(time) {
          const elapsed = time - startTime;
          const progress = Math.min(elapsed / duration, 1);
          const easeProgress = easeInOutCubic(progress);
          
          // 시작 인덱스와 목표 인덱스 사이의 최단 경로 계산
          let diff = targetIndex - startIndex;
          
          // 최단 경로 결정 (원형)
          if (Math.abs(diff) > cardCount / 2) {
            if (diff > 0) diff -= cardCount;
            else diff += cardCount;
          }
          
          // 현재 애니메이션 진행 상태의 인덱스 오프셋 계산
          const indexOffset = diff * easeProgress;
          
          // 카드 위치 업데이트
          updateCardPositions(indexOffset);
          
          if (progress < 1) {
            animationId = requestAnimationFrame(animate);
          } else {
            // 애니메이션 완료 시 현재 인덱스 업데이트
            currentIndex = targetIndex;
            updateCardPositions();
            isAnimating = false;
            animationId = null;
          }
        }
        
        // 애니메이션 시작
        cancelAnimationFrame(animationId);
        animationId = requestAnimationFrame(animate);
      }
      
      // 다음 카드로 이동
      function goNext() {
        goToCard(currentIndex + 1);
      }
      
      // 이전 카드로 이동
      function goPrev() {
        goToCard(currentIndex - 1);
      }
      
      // 이징 함수
      function easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      }

      // 값 범위 매핑 유틸리티 함수
      function map(value, in_min, in_max, out_min, out_max) {
        return (value - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
      }

      // 페이지 로드 후 약간의 지연을 두고 초기화
      if (document.readyState === 'complete') {
        setTimeout(init, 10);
      } else {
        window.addEventListener('load', function () {
          setTimeout(init, 10);
        });
      }
    })();
  </script>
</head>

<body>
  <section class="hero">
    <h2>Recent Posts</h2>

    <div class="carousel-container">
      <button class="nav-btn left">&#10094;</button>
      <div class="carousel">
        <div class="carousel-track">
          
          <a href="/2025/05/06/test1.html" class="carousel-card">
            <img src="/assets/thumbs/test.png" alt="thumbnail">
            <div class="text">
              <h3>test1</h3>
              <small>2025-05-06</small>
            </div>
          </a>
          
          <a href="/2025/05/05/test2.html" class="carousel-card">
            <img src="/assets/thumbs/test.png" alt="thumbnail">
            <div class="text">
              <h3>test2</h3>
              <small>2025-05-05</small>
            </div>
          </a>
          
          <a href="/2025/05/04/test3.html" class="carousel-card">
            <img src="/assets/thumbs/test.png" alt="thumbnail">
            <div class="text">
              <h3>test3</h3>
              <small>2025-05-04</small>
            </div>
          </a>
          
          <a href="/2025/05/03/test4.html" class="carousel-card">
            <img src="/assets/thumbs/test.png" alt="thumbnail">
            <div class="text">
              <h3>test4</h3>
              <small>2025-05-03</small>
            </div>
          </a>
          
          <a href="/2025/05/02/test5.html" class="carousel-card">
            <img src="/assets/thumbs/test.png" alt="thumbnail">
            <div class="text">
              <h3>test5</h3>
              <small>2025-05-02</small>
            </div>
          </a>
          
          <a href="/2025/05/01/test6.html" class="carousel-card">
            <img src="/assets/thumbs/test.png" alt="thumbnail">
            <div class="text">
              <h3>test6</h3>
              <small>2025-05-01</small>
            </div>
          </a>
          
          <a href="/2025/04/30/test7.html" class="carousel-card">
            <img src="/assets/thumbs/test.png" alt="thumbnail">
            <div class="text">
              <h3>test7</h3>
              <small>2025-04-30</small>
            </div>
          </a>
          
          <a href="/2025/04/29/test8.html" class="carousel-card">
            <img src="/assets/thumbs/test.png" alt="thumbnail">
            <div class="text">
              <h3>test8</h3>
              <small>2025-04-29</small>
            </div>
          </a>
          
        </div>
      </div>
      <button class="nav-btn right">&#10095;</button>
    </div>
  </section>

  <main>
    <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">test4</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2025-05-03T00:00:00+09:00" itemprop="datePublished">May 3, 2025
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>test</p>

  </div><a class="u-url" href="/2025/05/03/test4.html" hidden></a>
</article>

  </main>

</body>

</html>